name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# Ensure the token can publish to GitHub Packages (NuGet) and allow cache saves.
permissions:
  contents: read
  packages: write
  actions: write

jobs:
  build:
    name: ${{ matrix.name }} â€¢ Qt ${{ matrix.qt-version }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-22.04
            name: ubuntu-22.04
            qt-version: "6.6.3"
          - os: windows-latest
            name: windows-latest
            qt-version: "6.6.3"
          - os: macos-latest
            name: macos-latest (arm64)
            qt-version: "6.6.3"
            arch: arm64
          - os: macos-15-intel
            name: macos-15-intel (x86_64)
            qt-version: "6.6.3"
            arch: x86_64

    runs-on: ${{ matrix.os }}

    # Cross-OS environment for vcpkg binary caching via GitHub Packages (NuGet)
    env:
      FEED_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
      NUGET_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      VCPKG_FEATURE_FLAGS: binarycaching
      VCPKG_BINARY_SOURCES: >-
        clear;nuget,https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json,readwrite
      NUGET_CREDENTIALPROVIDERS_PATH: ''
      NUGET_PLUGIN_PATHS: ''
      VCPKG_NUGET_EXTRA_ARGS: "-NonInteractive -ForceEnglishOutput -Verbosity detailed -Timeout 600"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Qt ${{ matrix.qt-version }}
        uses: jurplel/install-qt-action@v4
        with:
          version: ${{ matrix.qt-version }}
          modules: 'qtpdf'
          cache: true

      - name: Set macOS architecture variables
        if: runner.os == 'macOS'
        shell: bash
        run: |
          if [ "${{ matrix.arch }}" == "x86_64" ]; then
            echo "BREW_HOME=/usr/local" >> $GITHUB_ENV
          else
            echo "BREW_HOME=$(brew --prefix)" >> $GITHUB_ENV
          fi

      - name: Add Qt bin to PATH (Windows)
        if: runner.os == 'Windows'
        run: echo "${{ env.QT_ROOT_DIR }}\\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Install build dependencies (Windows)
        if: runner.os == 'Windows'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install build dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            autoconf automake libtool pkg-config autoconf-archive ninja-build mono-complete \
            xvfb libxcb-cursor0 libxcb-cursor-dev '^libxcb.*-dev' libx11-xcb-dev \
            libfontconfig1-dev libfreetype6-dev libegl1-mesa-dev libgbm-dev \
            libgl1-mesa-dev libgles2-mesa-dev libxi-dev libdbus-1-dev

      - name: Install build dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          # Use the brew path set in the step above
          BREW_BIN="${{ env.BREW_HOME }}/bin/brew"
          
          ${BREW_BIN} update
          
          if [ "${{ matrix.arch }}" == "x86_64" ]; then
            # Install Python first and overwrite links to prevent conflicts (e.g., from mono)
            ${BREW_BIN} install python --overwrite
            # Install the rest
            ${BREW_BIN} install autoconf automake libtool pkg-config gettext autoconf-archive ninja mono
          else
            # For arm64, no known conflicts, install all at once
            ${BREW_BIN} install autoconf automake libtool pkg-config gettext autoconf-archive ninja mono python
          fi
          
          # Set paths using the correct brew prefix
          echo "${{ env.BREW_HOME }}/opt/gettext/bin" >> $GITHUB_PATH
          echo "ACLOCAL_PATH=${{ env.BREW_HOME }}/share/aclocal:${{ env.BREW_HOME }}/opt/gettext/share/aclocal" >> $GITHUB_ENV
          echo "${{ env.BREW_HOME }}/bin" >> $GITHUB_PATH

      - name: Bootstrap vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgGitCommitId: a2efad2ec955878d30db81d730490e931b84850f
          runVcpkgInstall: false

      - name: Allow vcpkg to download helper tools (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          echo "VCPKG_FORCE_SYSTEM_BINARIES=" >> "$GITHUB_ENV"

      - name: Show suggested vcpkg baseline (to update vcpkg.json)
        shell: bash
        run: |
          "${VCPKG_ROOT}/vcpkg" x-update-baseline || true

      - name: Configure NuGet (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          USERNAME: ${{ github.repository_owner }}
          FEED_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
        run: |
          $nuget = & "${Env:VCPKG_ROOT}\vcpkg.exe" fetch nuget
          & $nuget sources remove -Name GitHubPackages -NonInteractive 2>$null | Out-Null
          & $nuget sources add `
            -Source "$Env:FEED_URL" `
            -Name GitHubPackages `
            -UserName "${Env:GITHUB_REPOSITORY_OWNER}" `
            -Password "${Env:NUGET_AUTH_TOKEN}" `
            -StorePasswordInClearText `
            -NonInteractive
          & $nuget setapikey "${Env:NUGET_AUTH_TOKEN}" -Source "$Env:FEED_URL" -NonInteractive

      - name: Configure NuGet (Linux / macOS)
        if: runner.os != 'Windows'
        shell: bash
        env:
          USERNAME: ${{ github.repository_owner }}
          FEED_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
        run: |
          unset VCPKG_FORCE_SYSTEM_BINARIES
          nuget_exe="$("${VCPKG_ROOT}/vcpkg" fetch nuget 2>/dev/null | tail -n1)"
          if [ ! -f "$nuget_exe" ]; then
          echo "::error::vcpkg fetch nuget did not return a usable path. Got: '$nuget_exe'"
          "${VCPKG_ROOT}/vcpkg" fetch nuget || true
          exit 1
          fi
          mono "$nuget_exe" sources remove -Name GitHubPackages -NonInteractive >/dev/null 2>&1 || true
          mono "$nuget_exe" sources add \
            -Source "${FEED_URL}" \
            -Name GitHubPackages \
            -UserName "${GITHUB_REPOSITORY_OWNER}" \
            -Password "${NUGET_AUTH_TOKEN}" \
            -StorePasswordInClearText \
            -NonInteractive
          mono "$nuget_exe" setapikey "${NUGET_AUTH_TOKEN}" -Source "${FEED_URL}" -NonInteractive

      - name: Run vcpkg install (Windows)
        if: runner.os == 'Windows'
        shell: bash
        env:
          VCPKG_DEFAULT_TRIPLET: x64-windows
        run: |
          unset VCPKG_FORCE_SYSTEM_BINARIES
          "${VCPKG_ROOT}/vcpkg" install --triplet=${VCPKG_DEFAULT_TRIPLET}

      - name: Run vcpkg install (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          unset VCPKG_FORCE_SYSTEM_BINARIES
          "${VCPKG_ROOT}/vcpkg" install --triplet=x64-linux

      - name: Run vcpkg install (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          unset VCPKG_FORCE_SYSTEM_BINARIES
          if [ "${{ matrix.arch }}" == "x86_64" ]; then
            "${VCPKG_ROOT}/vcpkg" install --triplet=x64-osx
          else
            "${VCPKG_ROOT}/vcpkg" install --triplet=arm64-osx
          fi

      - name: Configure CMake
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # Windows configuration
            cmake -S . -B build \
              -G "Visual Studio 17 2022" -A x64 \
              -DCMAKE_TOOLCHAIN_FILE="${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake" \
              -DCMAKE_PREFIX_PATH="${{ env.Qt6_DIR }}" \
              -DENABLE_TESTING=ON
          else
            # Common flags for Linux/macOS
            CMAKE_FLAGS="-S . -B build \
              -G Ninja \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake \
              -DCMAKE_PREFIX_PATH=${{ env.Qt6_DIR }} \
              -DENABLE_TESTING=ON"
          
            if [[ "${{ runner.os }}" == "macOS" ]]; then
              # Add the release signing flag ONLY for macOS
              # CMAKE_FLAGS="$CMAKE_FLAGS -DRELEASE_BUILD=ON" 
              if [ "${{ matrix.arch }}" == "x86_64" ]; then
                CMAKE_FLAGS="$CMAKE_FLAGS -DCMAKE_OSX_ARCHITECTURES='x86_64' -DVCPKG_TARGET_TRIPLET=x64-osx"
              else
                CMAKE_FLAGS="$CMAKE_FLAGS -DCMAKE_OSX_ARCHITECTURES='arm64' -DVCPKG_TARGET_TRIPLET=arm64-osx"
              fi
            else
              # Linux flags
              CMAKE_FLAGS="$CMAKE_FLAGS -DVCPKG_TARGET_TRIPLET=x64-linux"
            fi
          
            unset VCPKG_FORCE_SYSTEM_BINARIES
          
            # Run cmake with all flags
            cmake $CMAKE_FLAGS
          fi

      - name: Build (Release)
        shell: bash
        run: cmake --build build --config Release --target CognitivePipelines unit_tests integration_tests -j 2

      - name: Deploy and Ad-hoc Sign (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: cmake --build build --target macos_deploy_all --config Release

      - name: Deploy Qt dependencies (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -e
          # Download linuxdeployqt AppImage
          curl -LO https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage
          chmod +x linuxdeployqt-continuous-x86_64.AppImage
          # Create a convenience symlink so we can call 'linuxdeployqt' directly (matches docs/requirements)
          ln -sf ./linuxdeployqt-continuous-x86_64.AppImage linuxdeployqt
          # Prepare deployment directory structure (AppDir standard)
          APPDIR="AppDir" # Define AppDir name
          mkdir -p "${APPDIR}/usr/bin"
          mkdir -p "${APPDIR}/usr/lib"
          # --- Create directories for desktop file and icon ---
          mkdir -p "${APPDIR}/usr/share/applications"
          mkdir -p "${APPDIR}/usr/share/icons/hicolor/256x256/apps" # Standard icon path
          # Copy executables into the AppDir
          cp build/bin/CognitivePipelines "${APPDIR}/usr/bin/"
          # Copy Tests
          cp build/bin/unit_tests "${APPDIR}/usr/bin/"
          cp build/bin/integration_tests "${APPDIR}/usr/bin/"
          # Copy QtNodes shared library (required since BUILD_SHARED_LIBS=ON)
          echo "Copying QtNodes shared library..."
          # QtNodes may output to build/lib/ instead of build/bin/ on Linux
          if [ -f build/bin/libQtNodes.so ]; then
            cp build/bin/libQtNodes.so* "${APPDIR}/usr/lib/"
            echo "Copied QtNodes from build/bin/"
          elif [ -f build/lib/libQtNodes.so ]; then
            cp build/lib/libQtNodes.so* "${APPDIR}/usr/lib/"
            echo "Copied QtNodes from build/lib/"
          else
            echo "ERROR: libQtNodes.so not found in build/bin/ or build/lib/"
            echo "Contents of build/bin/:"
            ls -la build/bin/
            echo "Contents of build/lib/:"
            ls -la build/lib/ || echo "build/lib/ does not exist"
            exit 1
          fi
          # ---Copy desktop files and icon ---
          cp packaging/linux/CognitivePipelines.desktop "${APPDIR}/usr/share/applications/"
          cp packaging/linux/unit_tests.desktop "${APPDIR}/usr/share/applications/"
          cp packaging/linux/integration_tests.desktop "${APPDIR}/usr/share/applications/"
          cp packaging/linux/CognitivePipelines.png "${APPDIR}/usr/share/icons/hicolor/256x256/apps/"
          cp packaging/linux/unit_tests.png "${APPDIR}/usr/share/icons/hicolor/256x256/apps/"
          cp packaging/linux/integration_tests.png "${APPDIR}/usr/share/icons/hicolor/256x256/apps/"
          # Run linuxdeployqt
          export PATH="${QT_ROOT_DIR}/bin:$PATH"
          export LD_LIBRARY_PATH="${QT_ROOT_DIR}/lib:$LD_LIBRARY_PATH"
          # Prune Qt SQL drivers that require external client libraries.
          # We only need the SQLite driver (libqsqlite.so); removing others avoids linuxdeployqt ldd failures
          # such as 'libmimerapi.so => not found' for libqsqlmimer.so on CI runners.
          if [ -d "${QT_ROOT_DIR}/plugins/sqldrivers" ]; then
            echo "Pruning Qt SQL drivers to keep only SQLite..."
            find "${QT_ROOT_DIR}/plugins/sqldrivers" -maxdepth 1 -type f -name 'libqsql*.so' ! -name '*sqlite*' -print -delete || true
          fi
          # Extract version from CMakeLists.txt (example, might need refinement based on your exact file)
          PROJECT_VERSION=$(grep -oP 'project\(CognitivePipelines VERSION \K[0-9]+\.[0-9]+\.[0-9]+' CMakeLists.txt)
          export VERSION=${PROJECT_VERSION:-0.0.0} # Set VERSION env var, default to 0.0.0 if not found
          echo "Setting AppImage version to: $VERSION"         
          # Define the master AppDir we duplicate
          MASTER_APPDIR="${APPDIR}"
          # Create temporary copies of the populated AppDir ---
          echo "Creating separate AppDir copies..."
          cp -r "${MASTER_APPDIR}" "AppDir_Main"
          cp -r "${MASTER_APPDIR}" "AppDir_Unit"
          cp -r "${MASTER_APPDIR}" "AppDir_Integration"
          # Build Main App ---
          echo "Building CognitivePipelines AppImage..."
          # Clean up the other .desktop files so linuxdeployqt isn't confused
          rm "AppDir_Main/usr/share/applications/unit_tests.desktop"
          rm "AppDir_Main/usr/share/applications/integration_tests.desktop"
          # Run linuxdeployqt on its own clean directory
          # Use -executable flag to explicitly process libQtNodes.so so it's properly bundled with rpaths
          ./linuxdeployqt-continuous-x86_64.AppImage \
            "AppDir_Main/usr/share/applications/CognitivePipelines.desktop" \
            -executable="AppDir_Main/usr/lib/libQtNodes.so" \
            -appimage
          # This will create 'CognitivePipelines-....AppImage'
          # Build Unit Tests ---
          echo "Building unit_tests AppImage..."
          # Clean up the other .desktop files
          rm "AppDir_Unit/usr/share/applications/CognitivePipelines.desktop"
          rm "AppDir_Unit/usr/share/applications/integration_tests.desktop"
          # Run linuxdeployqt on its own clean directory
          # Use -executable flag to explicitly process libQtNodes.so so it's properly bundled with rpaths
          ./linuxdeployqt-continuous-x86_64.AppImage \
            "AppDir_Unit/usr/share/applications/unit_tests.desktop" \
            -executable="AppDir_Unit/usr/lib/libQtNodes.so" \
            -appimage
          # This will create 'CognitivePipelines_unit_tests-....AppImage'
          # Build Integration Tests ---
          echo "Building integration_tests AppImage..."
          # Clean up the other .desktop files
          rm "AppDir_Integration/usr/share/applications/CognitivePipelines.desktop"
          rm "AppDir_Integration/usr/share/applications/unit_tests.desktop"
          # Run linuxdeployqt on its own clean directory
          # Use -executable flag to explicitly process libQtNodes.so so it's properly bundled with rpaths
          ./linuxdeployqt-continuous-x86_64.AppImage \
            "AppDir_Integration/usr/share/applications/integration_tests.desktop" \
            -executable="AppDir_Integration/usr/lib/libQtNodes.so" \
            -appimage
          # This will create 'CognitivePipelines_integration_tests-....AppImage'
          # Clean up temporary directories ---
          echo "Cleaning up temporary AppDirs..."
          rm -rf "AppDir_Main" "AppDir_Unit" "AppDir_Integration"
          echo "All AppImages created successfully."          
          # Create a single distributable ZIP containing all AppImages + desktop/icon files
          echo "Creating Linux bundle zip..."
          echo "Contents"
          ls -l
          zip -j cognitive-pipelines-ubuntu-bundle.zip \
            CognitivePipelines*.AppImage \
            packaging/linux/CognitivePipelines.desktop \
            packaging/linux/unit_tests.desktop \
            packaging/linux/integration_tests.desktop \
            packaging/linux/CognitivePipelines.png \
            packaging/linux/unit_tests.png \
            packaging/linux/integration_tests.png || {
              echo "Zip creation failed"; ls -la; exit 1;
            }

      - name: Deploy Qt dependencies (Windows)
        if: runner.os == 'Windows'
        shell: bash # Use bash to easily access QT_ROOT_DIR env var
        run: |
          # The output directory for deployment
          DEPLOY_DIR="${{ github.workspace }}/deploy/windows"
          mkdir -p "$DEPLOY_DIR"
          BUILD_BIN_DIR="${{ github.workspace }}/build/bin/Release" # Source directory
          VCPKG_BIN_DIR_RAW="${{ env.VCPKG_ROOT }}_installed/x64-windows/bin"
          VCPKG_BIN_DIR="${VCPKG_BIN_DIR_RAW//\\//}" # Replace all \ with /   

          # Copy the executables to the deployment dir first
          cp "${{ github.workspace }}/build/bin/Release/CognitivePipelines.exe" "$DEPLOY_DIR/"
          cp "${{ github.workspace }}/build/bin/Release/unit_tests.exe" "$DEPLOY_DIR/"
          cp "${{ github.workspace }}/build/bin/Release/integration_tests.exe" "$DEPLOY_DIR/"
          
          echo "Deploying Qt dependencies for CognitivePipelines ..."
          "${QT_ROOT_DIR}/bin/windeployqt.exe" "$DEPLOY_DIR/CognitivePipelines.exe"
          
          echo "Deploying Qt dependencies for integration_tests..."
          "${QT_ROOT_DIR}/bin/windeployqt.exe" "$DEPLOY_DIR/integration_tests.exe"
          
          # Copy QtNodes
          echo "Copying QtNodes library..."
          cp "${{ github.workspace }}/build/bin/Release/QtNodes.dll" "$DEPLOY_DIR/"
          # Copy CPR
          cp "${BUILD_BIN_DIR}/cpr.dll" "$DEPLOY_DIR/" || echo "cpr.dll not found, skipping." 
          # Copy CPR's dependencies (Curl, OpenSSL, zlib etc.) FROM VCPKG BIN DIR
          echo "Copying CPR dependencies from vcpkg install tree..."
          cp "${VCPKG_BIN_DIR}/"libcurl*.dll "$DEPLOY_DIR/" || echo "libcurl*.dll not found."
          cp "${VCPKG_BIN_DIR}/"libcrypto*.dll "$DEPLOY_DIR/" || echo "libcrypto*.dll not found."
          cp "${VCPKG_BIN_DIR}/"libssl*.dll "$DEPLOY_DIR/" || echo "libssl*.dll not found."
          cp "${VCPKG_BIN_DIR}/"zlib*.dll "$DEPLOY_DIR/" || echo "zlib*.dll not found."
          echo "Copying GTest dependencies from vcpkg install tree..."
          cp "${VCPKG_BIN_DIR}/"gtest*.dll "$DEPLOY_DIR/" || echo "gtest*.dll not found." # also copies gtest_main
          
          echo "Deployment directory contents:"
          ls -l "$DEPLOY_DIR"  

      - name: Run Unit Tests (Windows)
        if: runner.os == 'Windows'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: .\\build\\bin\\Release\\unit_tests.exe

      - name: Run Unit Tests (macOS)
        if: runner.os == 'macOS'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: ./build/bin/unit_tests.app/Contents/MacOS/unit_tests

      - name: Run Unit Tests (Linux)
        if: runner.os == 'Linux'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: xvfb-run ./build/bin/unit_tests

      - name: Run Integration Tests (Windows)
        if: runner.os == 'Windows'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: bash
        run: |
          set -o pipefail
          .\\build\\bin\\Release\\integration_tests.exe 2>&1 | tee integration_test_log.txt

      - name: Run Integration Tests (macOS)
        if: runner.os == 'macOS'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: ./build/bin/integration_tests.app/Contents/MacOS/integration_tests

      - name: Run Integration Tests (Linux)
        if: runner.os == 'Linux'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        # Retry loop ---
        run: |
          for i in 1 2 3; do
            echo "Attempt $i to run integration tests..."
            xvfb-run ./build/bin/integration_tests && break # Success, exit loop
            if [ $i -lt 3 ]; then
              echo "Attempt $i failed. Retrying in 5 seconds..."
              sleep 5
            else
              echo "Attempt $i failed. No more retries."
              exit 1 # Explicitly fail the step after last attempt
            fi
          done

      # -----------------------------------------------------------------
      # ---           Archive Build Artifacts                         ---
      # -----------------------------------------------------------------

      - name: Archive build artifacts (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: cognitive-pipelines-windows
          path: ${{ github.workspace }}/deploy/windows/
          retention-days: 7

      - name: cognitive-pipelines-ubuntu-bundle
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: cognitive-pipelines-ubuntu-bundle
          path: cognitive-pipelines-ubuntu-bundle.zip
          retention-days: 7

      - name: Archive build artifacts (macOS)
        if: runner.os == 'macOS'
        uses: actions/upload-artifact@v4
        with:
          name: cognitive-pipelines-macos-${{ matrix.arch }}
          path: ${{ github.workspace }}/build/bin/*.app
          retention-days: 7